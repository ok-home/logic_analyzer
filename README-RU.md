[En](/README.md)

| Supported Targets |  
| ESP32 ESP32S3 ESP32C3 ESP32P4 | 
| ----------------- |

# Логический анализатор на ESP32 для самодиагностики
 - Нет необходимости покупать и подключать внешний логичекий анализатор
 - Подключается как компонент к вашей программе ( ESP IDF )
 - Вывод информации на WEB интерфейс или Sigrok PulseView
 - Поддерживаемые SOC -> ESP32, ESP32S3, ESP32C3, ESP32P4

![WebSocket](/la_ws.jpg)
![PulseView](/sigrok_esp.jpg)

## Основные параметры
|                      | Channels | Max<br>Sample<br>Count(2) | Max<br>Sample<br>Rate | ESP<br>Module |        Free GPIO & Clock Source<br>Required        |
|:--------------------:|:--------:|:-------------------------:|:---------------------:|:-------------:|:--------------------------------------------------:|
|         ESP32        |    16    |          50 000           |         40 MHz        |   I2S0/I2S1   | NO                                                 |
|        ESP32S3       |  8<br>16 |     140 000<br>70 000     |    80 MHz<br>40 MHz   |    LCD_CAM    | One Free GPIO<br>One LEDC Channel for slow PCLK(3) |
| ESP32S3<br>PSRAM8(1) |  8<br>16 |   8 000 000<br>4 000 000  |    10 MHz<br>5 MHZ    |    LCD_CAM    | One Free GPIO<br>One LEDC Channel for slow PCLK(3) |
|       ESP32C3(4)     |    4     |          60 000           |         80 MHz        |    GPSPI2     | NO                                                 |
|       ESP32P4(5)     |  8<br>16 |16 000 000-32 000 000<br>8 000 000-16 000 000|80 MHz Ram<br>80 MHz Psram   |    LCD_CAM    | One Free GPIO for PCLK<br> One free GPIO for ETM Trigger(Opt)<br> |
|       ESP32P4(5)     |  8<br>16 |16 000 000-32 000 000<br>8 000 000-16 000 000|80 MHz Ram<br>80 MHz Psram   |    PARL_IO    |  One free GPIO for ETM Trigger(Opt)<br> |

1. Не рекомендую использовать этот режим без необходимости. PSRAM сильно нагружает SPI шину, возможны артефакты и задержки в работе основной программы. Для корректной работы с Кэшем требуется ESP IDF ver 5.2 ( в текущей версии master branch )
2. Максимальное количество сэмплов зависит от количества свободной памяти при работе вашей программы, анализатор ограничит количество сэмплов и вернет максимально возможное.
3. ESP32S3 -> требуется один, никуда не подключенный вывод GPIO для сигнала PCLK, для частоты сэмплов меньше 1 MHz - можно разрешить подключение 1 канала LEDC
4. ESP32C3 -> триггер не использует HiLevel прерывания, Задержка от триггера до начала данных 1,3-1,5 мкСек. SUMP работает врежиме 8 каналов, старшие 4 канала не используются.
5. ESP32P4 -> максимальное количество сэмплов зависит от объема встроенной PSRAM, свободной памяти RAM. Триггер использует обычные прерывания по фронту с задержкой до начала данных 1,3-1,5 мкСек или ETM с задержкой 150 нСек. Для режима ETM требуется один свободный GPIO

 - 1 канал триггера захвата. Триггер организован на прерываниях по фронтам. В ESP32 прерывания обрабатываются примерно 2 мкСек (rev0.1) - Соответственно задержка от триггера до начала данных, около 2-х мкСек. В текущих версиях триггер переведен на Hilevel прерывания ( level 5 ), Задержка от триггера до начала данных уменьшена до 0,3 мкСек.
 - Все настройки режимов вынесены в Menuconfig. Каналы, Триггер, Частота сэмплов дополнительно настраивается в WEB интерфейсе
 - Анализатор позволяет работать на измеряемом устройстве. Устанавливаем софт на пациента, как стандартный внешний компонент ESP IDF, настраиваем GPIO на каналы ( проверено - GPIO, I2C, I2S, SPI, LED PWM, IRQ_GPIO, UART, USB, думаю что остальное также будет работать ), показывает как входные так и выходные сигналы пациента. Ограничения по триггеру в этом режиме - нельзя назначить триггер на пин (GPIO) у которого назначено прерывание на софте пациента ( анализатор перенастроит на себя ) - в последней версии (interrupt level 5) ограничение частично снято, но триггер будет срабатывать по тем фронтам(уровням), которые назначены на софте пациента.
 - Можно сделать анализатор как отдельное устройство, но не вижу особого смысла На рынке достаточное количество дешевых аналогов с похожими харатеристиками. Основное преимущество самодиагностики - подключили компонет к проекту и смотрим, что там происходит. Понятно что софт пациента может уже использовать всю память - тогда сильно уменьшится объем сэмплов - но хотя бы уровни и небольшое количество отсчетов все равно увидим.
  ## Простой web интерфейс
  - Подключение совсем без проводов
  - Простая настройка GPIO на каналы
  - Переключение количества каналов 8/16 и использования PSRAM
  - Просмотр сэмплов ( без анализатора протоколов )
  - Сохранение данных в .bin формате который потом можно при необходимости передать в Sigrok PulseView.
  ## В качестве визуализации и анализатора протоколов можно использовать Sigrok PulseView 
  - Открытый софт
  - Много анализаторов протокола
  - при прямом (SUMP) подключении используется UART для получения данных, протокол передачи "Openbench logic Sniffer & SUMP"
  - по умолчанию используется UART0 ESP32 можно ( а лучше нужно ) использовать другой порт, если он есть на вашем устройстве. Можно настроить в menuconfig. 
  - можно использовать ( рекомендую ) сохраненные данные из WEB интерфейса rawBin
  - рекомендую использовать прямое подключение к SUMP/Sigrok PulseView только при дефиците ресурсов ( Rom/Ram ). SUMP протокол очень маленький по объему кода.
  ## Известные баги
  - при использовании SUMP/Sigrok UART0 - необходимо отключить  весь дигностический вывод ESP32 (LOG LEVEL - NONE ), это не баг но существенное ограничение.
  - PulseView - для получения данных нужно нажать RUN 2 раза с интервалом 1-2 секунды ( причину не знаю )
  - PulseView - в режиме триггера не работает с кадрами меньше 1к ( причину не знаю )
  - PulseView - не принимает параметр максимальной частоты сэмплов - легко увидите частоты 50/100/200 мегаГерц.
  - PulseView - не работает предвыборка триггера ( ставим 0% ) - просто не делал, и в текущей архитектуре невозможно.
  - PulseView - невозможно поставить частоту выборки 40-80 MHz
  # Подключение LogicAnalyzer к проекту как компонент
   - смотрим документацию в ESP IDF - https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html#example-project
   - в качестве примера - https://github.com/ok-home/logic_analyzer/tree/master/logic_analyzer_example
  # Подключение PulseView
  - Connect to device
  - Choose the driver - Openbench logic Sniffer & SUMP
  - Serial Port - Speed - 921600 ( скорость можно переопределить, на моем кабеле работает на этой скорости )
  - Scan for Device - должен появиться ESP32 with 8/16 channels
  - Дальше читаем руководство по PulseView.
  - Для чтения .bin файлов - просто импорт rawBin, 8/16 каналов, нужная частота сэмплов.
  # Подключение Web интерфейса - заходим на страничку по адресу http://xxx.xxx.xxx.xxx/la
  # Интерфейс программы
  ## Условно состоит из 3-х частей
  ### include/logic_analyzer_hal.h
  - Получает сэмплы в буфер ESP32
  - logic_analyzer_config_t - конфигурация захвата
  - start_logic_analyzer(logic_analyzer_config_t *config) - старт захвата
  - void (*logic_analyzer_cb_t)(uint8_t *samle_buf, int samples, int sample_rate) - каллбэк после захвата данных
  ### include/logic_analyzer_sump.h
  - работа с PulseView 
  - logic_analyzer_sump(); 
  ### include/logic_analyzer_ws_server.h
  - Стартуем web сервер с поддержкой websocket - проверить в menuconfig поддержку websocket
  - logic_analyzer_ws_server()
  ### include/logic_analyzer_ws.h
  - если на вашем устройстве уже установлен сервер с поддержкой websocket - просто зарегистрируйте uri handler
  - logic_analyzer_register_uri_handlers(httpd_handle_t server);
  ## Пример с тестовыми сэмплами
  ### logic_analyzer_example
  - test_sample_init() - включает простой генератор на 100 килогерц, пачку GPIO имульсов с большой скважностью и пачку GPIO импульсов сформированных по прерываниям. Никаких дополнительных подключений, проводков и пр. не нужно, уже будет показывать внутренности. При желании можете поставить 2 перемычки на пины - продублирует сигналы на GPIO.
  - вишенка на торте - подключаемся любым каналом на TXD0 и смотрим свой же uart0 (только web)
  ## Настройки вынесены в menuconfig
   - Общие настройки
     - ANALYZER_USE_HI_LEVEL_INTERRUPT - триггер через прерывания высокого уровня
     - ANALYZER_SEPARATE_MODE           - для работы как отдельное устройство ( своя настройка GPIO )
     - ANALYZER_USE_WS                  - использовать WEB интерфейс
     - ANALYZER_USE_SUMP                - подключаться непосредственно к PulseView по COM порту
     - ANALYZER_USE_PORT_ASSIGN         - настроить каналы по умолчанию (Каналы, триггер, частота количество сэмплов, Количество каналов, использоввание PSRAM)
   - Настройки для ESP32
     - ANALYZER_USE_I2S_CHANNEL         - используемый канал I2S ( 0/1 )
   - Настройки для ESP32S3
     - ANALYZER_PCLK_PIN                - номер GPIO для транзита PCLK
     - ANALYZER_USE_LEDC_TIMER_FOR_PCLK - подключать канал LEDC для частоты сэмплов меньше 1 MHz
   
  ## Для использования Hi-level interrupt необходимо в menuconfig поставить CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL = ESP_SYSTEM_CHECK_INT_LEVEL_4

  ## Добавлен CLI интерфейс для стабильной работы с PulseView при ограничении RAM
   - минимальное потребление RAM
   - простой скрипт logic_analyzer_cli/logic_analyzer_cli.py для сохранения сэмплов в RowBin файл (необходимо добавить зависимость PySerial)
   - параметры скрипта задаются в файле la_cfg.json ( шаблон файла создается автоматически при первом запуске скрипта), GPIO,TRIGGER,TRBGGER EDGE,SAMPLES,SAMPLE RATE,NUMBER CHANNELS,RAM/PSRAM.
   - подключение к коду программы
     - logic_analyzer_cli/include/logic_analyzer_cli.h
     - установить в menuconfig ANALYZER_USE_CLI и параметры UART/USB_SERIAL_JTAG
     - скомпилировать и загрузить код программы с подключеным logic_analyzer
     - подключиться к UART/USB
     - запустить logic_analyzer_cli.py с установлеными параметрами в файле la_cfg.json
    - подключение к PulseView
     - Import Raw binary logic data  - файл который создается скриптом
     - задание количества каналов и частоты сэмплов при первом импорте (esp32c3 - ставим 8 каналов, используются 4 младших ), в дальнейшем если эти параметры не меняются достаточно сделать Reload
   - для UART0 те же ограничения как для SUMP интерфейса
   - преимущества перед SUMP интерфейсом
     - смотрим выше известные баги PulseView - здесь их нет (кроме UART0)
     - простая настройка GPIO на каналы через la_cfg.json

![вывод cli интерфейса](/la_cli.jpg)

## Добавлена поддержка ESP32P4
- Поддерживается только CLI интерфейс
- Считывание данных в параллельном режиме 8/16 бит.
- Для модуля LCD_CAM, требуется один GPIO для сигнала PCLK
- Модуль PARL_IO поддерживает 8/15 бит. Бит 15 используется для триггера (ограничение HW)
- Можно выбрать режим триггера IRQ/ETM, режим ETM требует один дополнительный свободный GPIO
- Максимальная скорость выборки не зависит от количества каналов и вида памяти для буфера (Ram/Psram) и составляет 80 MHz ( для частоты PSRAM = 200 MHz )
- Количество сэмплов ограничено только размером свободной памяти (Ram/Psram), Максимальное количество сэмплов может составлять 32 000 000 для модулей с объемом Psram 32 Mbyte.

## В проекте использованы части кода
 - [esp32-cam](https://github.com/espressif/esp32-camera) for I2S DMA
 - [EUA/ESP32_LogicAnalyzer](https://github.com/EUA/ESP32_LogicAnalyzer) for SUMP
